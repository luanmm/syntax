/**
 * LR parser for TypeScript generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode <parsing-mode> \
 *     --output ~/parser-class-name.ts
 */

// --------------------------------------------------------------
// Global variable EOF

/**
 * A special "end of file" symbol, used by tokenizer as well.
 */
const EOF = "$";

// --------------------------------------------------------------
// Tokenizer.

{{{TOKENIZER}}}

// --------------------------------------------------------------
// Productions array.

/**
 * Encoded grammar productions table, array of arrays.
 *
 * Format of an entry array:
 *
 * [ <Non-Terminal Index>, <RHS.Length>, <handler> ]
 *
 * Non-terminal indices are from 0 to Last Non-terminal index.
 * LR-algorithm uses length of RHS to pop symbols from the stack; this
 * length is stored as the second element of a record. The last element is
 * an optional name of the semantic action handler. The first record is always
 * a special marker [-1, 1] entry representing an augmented production.
 *
 * Example:
 *
 * [
 *     [-1, 1],
 *     [0, 3, "_handler1"],
 *     [0, 2, "_handler2"],
 *     ...
 * ]
 */
const productions: any[][] = {{{PRODUCTIONS}}};

// --------------------------------------------------------------
// Parsing table.

/**
 * An array of records, where index is a state number, and a value is a
 * map from an encoded symbol (number) to a parsing action.
 *
 * The parsing action can be "Shift/s", "Reduce/r", a state
 * transition number, or "Accept/acc".
 *
 * Example:
 *
 * [
 *   // 0
 *   {
 *     0: "1",
 *     3: "s8",
 *     4: "s2",
 *   },
 *   // 1
 *   {
 *     1: "s3",
 *     2: "s4",
 *     6: "acc",
 *   },
 *   ...
 * ]
 */
const table: object[] = {{{TABLE}}};

// --------------------------------------------------------------
// Global variable yy

/**
 * Storage object.
 */
let yy = {

    // Parser options
    options: {

        // Capture locations?
        captureLocations: {{{CAPTURE_LOCATIONS}}}
    }
};

// --------------------------------------------------------------
// Global variable __

/**
 * __ holds a result value from a production
 * handler. In the grammar usually used as $$.
 */
let __: any = null;

// --------------------------------------------------------------
// Global variable __loc

/**
 * __loc holds a result location info. In the grammar usually used as @$.
 */
let __loc: any = null;

// --------------------------------------------
// Location object.

class YyLoc {

    constructor(
        public startOffset: number,
        public endOffset: number,
        public startLine: number,
        public endLine: number,
        public startColumn: number,
        public endColumn: number
    ) { }
}

function yyloc(start: YyLoc, end: YyLoc): YyLoc {
    if (!yy.options.captureLocations) {
        return null;
    }

    // Epsilon doesn't produce location.
    if (!start || !end) {
        return start || end;
    }

    return new YyLoc(
        start.startOffset,
        end.endOffset,
        start.startLine,
        end.endLine,
        start.startColumn,
        end.endColumn
    );
}

// --------------------------------------------
// Parser.

/**
 * Entires on the parsing stack are:
 *
 * - an actual entry {symbol, semanticValue}, implemented by `StackEntry`.
 * - a state number
 */
class StackEntry {

    constructor(
        public symbol: number,
        public semanticValue: any,
        public loc: YyLoc
    ) { }
}

/**
 * Base class for the parser. Implements LR parsing algorithm.
 *
 * Should implement at least the following API:
 *
 * - parse(string stringToParse): object
 * - setTokenizer(Tokenizer tokenizer): void, or equivalent Tokenizer
 *   accessor property with a setter.
 */
class yyparse {

    private _tokenizer: Tokenizer = new Tokenizer();

    /**
     * On parse begin callback.
     *
     * Example: parser.onParseBegin = (string code) => { ... };
     */
    static onParseBegin: (code: string, tokenizer: Tokenizer) => void = null;

    /**
     * On parse end callback.
     *
     * Example: parser.onParseEnd = (object parsed) => { ... };
     */
    static onParseEnd: (parsed: object) => void = null;

    /**
     * Main parsing method which applies LR-algorithm.
     */
    parse(value: string): object {
        // On parse begin hook.
        if (yyparse.onParseBegin != null) {
            yyparse.onParseBegin(value, this._tokenizer);
        }

        this._tokenizer.initString(value);

        // Initialize the parsing stack to the initial state 0.
        const stack: any[] = [0];

        let token = this._tokenizer.getNextToken();
        let shiftedToken = null;

        // Main parsing loop.
        do {
            if (!token) {
                this.unexpectedEndOfInput();
            }

            let state = Number(stack[stack.length - 1]);
            let column = token.type;
            let entry = table[state][column];

            if (!entry) {
                this.unexpectedToken(token);
            }

            // ---------------------------------------------------
            // "Shift". Shift-entries always have 's' as their
            // first char, after which goes *next state number*, e.g. "s5".
            // On shift we push the token, and the next state on the stack.
            if (entry[0] == 's') {
                let loc: YyLoc = null;

                if (yy.options.captureLocations) {
                    loc = new YyLoc(
                        token.startOffset,
                        token.endOffset,
                        token.startLine,
                        token.endLine,
                        token.startColumn,
                        token.endColumn
                    );
                }

                // Push token.
                stack.push(new StackEntry(token.type, token.value, loc));

                // Push next state number: "s5" -> 5
                stack.push(Number(entry.slice(1)));

                shiftedToken = token;
                token = this._tokenizer.getNextToken();
            }

            // ---------------------------------------------------
            // "Reduce". Reduce-entries always have 'r' as their
            // first char, after which goes *production number* to
            // reduce by, e.g. "r3" - reduce by production 3 in the grammar.
            // On reduce, we pop of the stack number of symbols on the RHS
            // of the production, and their pushed state numbers, i.e.
            // total RHS * 2 symbols.
            else if (entry[0] == 'r') {
                // "r3" -> 3
                const productionNumber = Number(entry.slice(1));
                const production = productions[productionNumber];

                // Handler can be optional: [0, 3] - no handler,
                // [0, 3, "_handler1"] - has handler.
                const hasSemanticAction = production.length > 2;

                const semanticValueArgs = hasSemanticAction ? [] : null;

                const locationArgs = (
                    hasSemanticAction && yy.options.captureLocations
                        ? []
                        : null
                );

                // The length of RHS is stored in the production[1].
                let rhsLength = Number(production[1]);
                if (rhsLength != 0) {
                    while (rhsLength-- > 0) {
                        // Pop the state number.
                        stack.pop();

                        // Pop the stack entry.
                        let stackEntry = stack.pop();

                        // Collect all semantic values from the stack
                        // to the arguments list, which is passed to the
                        // semantic action handler.
                        if (hasSemanticAction) {
                            semanticValueArgs.unshift(stackEntry.semanticValue);

                            if (locationArgs) {
                                locationArgs.unshift(stackEntry.loc);
                            }
                        }
                    }
                }

                // Previous state is on top of the stack.
                let previousState = Number(stack[stack.length - 1]);

                // Reduce to the LHS, which is stored (encoded) in the production[0].
                let symbolToReduceWith = Number(production[0]);

                let reduceStackEntry = new StackEntry(
                    symbolToReduceWith,
                    null, // updated further if there is semantic action.
                    null // updated later
                );

                // Execute the semantic action handler.
                if (hasSemanticAction) {
                    yytext = shiftedToken != null ? shiftedToken.value : null;
                    yyleng = shiftedToken != null ? shiftedToken.value.length : 0;

                    const semanticActionName = production[2];
                    const semanticActionHandler = this[semanticActionName];

                    const semanticActionArgs = (
                        locationArgs !== null
                            ? semanticValueArgs.concat(locationArgs)
                            : semanticValueArgs
                    );

                    // Call the action, the result is in __.
                    semanticActionHandler.apply(this, semanticActionArgs);

                    // And patch the `semanticValue` with the result.
                    reduceStackEntry.semanticValue = __;

                    // Add location object if needed.
                    if (locationArgs) {
                        reduceStackEntry.loc = __loc;
                    }
                }

                // Then push LHS (reduced entry) onto the stack.
                stack.push(reduceStackEntry);

                // And the next state number.
                const nextState = table[previousState][symbolToReduceWith];
                stack.push(nextState);

            }
            // ---------------------------------------------------
            // Accept. Pop starting production and its state number.
            else if (entry == "acc") {
                // Pop state number.
                stack.pop();

                // Pop the parsed value.
                const parsed = stack.pop();

                if (stack.length != 1 ||
                    stack[stack.length - 1] != 0 ||
                    this._tokenizer.hasMoreTokens()) {
                    this.unexpectedToken(token);
                }

                const parsedValue = parsed.semanticValue;
                if (yyparse.onParseEnd != null) {
                    yyparse.onParseEnd(parsedValue);
                }

                return parsedValue;
            }

        } while (this._tokenizer.hasMoreTokens() || stack.length > 1);

        return null;
    }

    private unexpectedToken(token: Token): void {
        if (token.type === EOF_TOKEN.type) {
            this.unexpectedEndOfInput();
        }

        this._tokenizer.throwUnexpectedToken(
            token.value,
            token.startLine,
            token.startColumn
        );
    }

    private unexpectedEndOfInput(): void {
        this.parseError("Unexpected end of input.");
    }

    private parseError(message: string): void {
        throw new SyntaxError("Parse error: " + message);
    }

}

{{{MODULE_INCLUDE}}}

/**
 * An actual parser class.
 */
export { yyparse as {{{PARSER_CLASS_NAME}}} }